# 流处理
在本章中，我们将把事件流（event stream）视为一种数据管理机制：无界限，增量处理，与上一章中批量数据相对应。

***

# 传递事件流 Transmitting Event Streams
在批处理中，文件被写入一次，然后可能被多个作业读取。类似地，在流处理术语中，一个事件由 生产者（producer） （也称为 发布者（publisher） 或 发送者（sender） ）生成一次，然后可能由多个 消费者（consumer） （ 订阅者（subscribers） 或 接收者（recipients） ）进行处理【3】。在文件系统中，文件名标识一组相关记录；在流式系统中，相关的事件通常被聚合为一个 主题（topic） 或 流（stream） 。

## 消息系统 Messaging Systems
* 向消费者通知新事件的常用方式是使用消息传递系统（messaging system）：生产者发送包含事件的消息，然后将消息推送给消费者
* 在这个发布/订阅模式中
  * 如果生产者发送消息的速度比消费者能够处理的速度快会发生什么？
    * 有三种选择：系统可以丢掉消息，将消息放入缓冲队列，或使用背压（backpressure）（也称为流量控制（flow control）；即阻塞生产者，以免其发送更多的消息）。
  * 如果节点崩溃或暂时脱机，会发生什么情况？ —— 是否会有消息丢失？
    * 与数据库一样，持久性可能需要写入磁盘和/或复制的某种组合（参阅“复制和持久性”），这是有代价的。如果你能接受有时消息会丢失，则可能在同一硬件上获得更高的吞吐量和更低的延迟。

### 直接从生产者传递给消费者 Direct messaging from producers to consumers
* 许多消息传递系统使用生产者和消费者之间的直接网络通信，而不通过中间节点
* 尽管这些直接消息传递系统在设计它们的环境中运行良好，但是它们通常要求应用代码意识到消息丢失的可能性。它们的容错程度极为有限：即使协议检测到并重传在网络中丢失的数据包，它们通常也只是假设生产者和消费者始终在线。

### 消息代理 Message brokers
* 一种针对处理消息流而优化的数据库。它作为服务器运行，生产者和消费者作为客户端连接到服务器
* 通过将数据集中在代理上，这些系统可以更容易地容忍来来去去的客户端（连接，断开连接和崩溃），而持久性问题则转移到代理的身上。一些消息代理只将消息保存在内存中，而另一些消息代理（取决于配置）将其写入磁盘，以便在代理崩溃的情况下不会丢失。
* 排队的结果是，消费者通常是异步（asynchronous）的

### 消息代理与数据库对比 Message brokers compared to databases
* 数据库通常保留数据直至显式删除，而大多数消息代理在消息成功递送给消费者时会自动删除消息
* 大多数消息代理都认为它们的工作集相当小—— 即队列很短
* 数据库通常支持二级索引和各种搜索数据的方式，而消息代理通常支持按照某种模式匹配主题，订阅其子集。
* 相比之下，消息代理不支持任意查询，但是当数据发生变化时（即新消息可用时），它们会通知客户端。
* 这是关于消息代理的传统观点，它被封装在诸如JMS和AMQP的标准中，并且被诸如RabbitMQ，ActiveMQ，HornetQ，Qpid，TIBCO企业消息服务，IBM MQ，Azure Service Bus和Google Cloud Pub/Sub实现。

### 多个消费者 Multiple consumers







