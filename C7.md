事务(transaction)是应用程序将多个读写操作组合成一个逻辑单元的一种方式。事务中的所有读写操作被视作单个操作来执行：整个事务要么成功（提交（commit））要么失败（中止（abort），回滚（rollback））。

# 事务的棘手概念
几乎所有的关系型数据库和一些非关系数据库都支持事务

## ACID的含义
ACID代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）和持久性（Durability）。

### 原子性（Atomicity）
* 相似但又微妙不同的东西
* 不是关于并发（concurrent）的
* 原子性的定义特征是：能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。 或许 可中止性（abortability） 是更好的术语，但本书将继续使用原子性，因为这是惯用词。

### 一致性（Consistency）
对数据的一组特定陈述必须始终成立。即不变量（invariants）

### 隔离性（Isolation）
同时执行的事务是相互隔离的：它们不能相互冒犯

### 持久性（Durability）
* 持久性 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。
* 为了提供持久性保证，数据库必须等到这些写入或复制完成后，才能报告事务成功提交。

## 单对象和多对象操作

### 单对象写入
* 对单节点上的单个对象（例如键值对）上提供原子性和隔离性。
* 同样流行的是 比较和设置（CAS, compare-and-set） 操作，当值没有并发被其他人修改过时，才允许执行写操作。可以防止在多个客户端尝试同时写入同一个对象时丢失更新，但它们不是通常意义上的事务。CAS以及其他单一对象操作被称为“轻量级事务”，甚至出于营销目的被称为“ACID”
* 事务通常被理解为，将多个对象上的多个操作合并为一个执行单元的机制

### 多对象事务的需求
关系型数据库，文档型数据库，具有二级index的数据库

### 处理错误和中止
* ACID数据库基于这样的哲学：如果数据库有违反其原子性，隔离性或持久性的危险，则宁愿完全放弃事务
* 无主复制的数据存储，数据库将做尽可能多的事，运行遇到错误时，它不会撤消它已经完成的事情“ ——所以，从错误中恢复是应用程序的责任。
* 尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美


# 弱隔离级别
* 当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。
* 数据库一直试图通过提供事务隔离（transaction isolation） 来隐藏应用程序开发者的并发问题。从理论上讲，隔离可以通过假装没有并发发生，让你的生活更加轻松：可序列化（serializable） 的隔离等级意味着数据库保证事务的效果与连续运行（即一次一个，没有任何并发）是一样的。
* 可序列化有性能损失。因此，系统通常使用较弱的隔离级别来防止一部分。

## 读已提交
最基本的事务隔离级别

### 没有脏读
* 从数据库读时，只能看到已提交的数据（没有脏读（dirty reads））。
* 如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新
* 如果事务中止，则所有写入操作都需要回滚

### 没有脏写
* 写入数据库时，只会覆盖已经写入的数据（没有脏写（dirty writes））。
* 如果事务更新多个对象，脏写会导致不好的结果

### 实现读已提交
* 防止脏写：行锁（row-level lock）
* 防止脏读：对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。 当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。

## 快照隔离和可重复读 Snapshot Isolation and Repeatable Read
很多地方可能会产生并发错误。是有些情况下，不能容忍这种暂时的不一致：
* 备份：备份进程运行时，数据库仍然会接受写入操作。因此备份可能会包含一些旧的部分和一些新的部分。如果从这样的备份中恢复，那么不一致（如消失的钱）就会变成永久的。
* 分析查询和完整性检查
* 快照隔离（snapshot isolation）：每个事务都从数据库的一致快照（consistent snapshot） 中读取——也就是说，每个事务也只能看到该特定时间点的旧数据

### 实现快照隔离



