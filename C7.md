事务(transaction)是应用程序将多个读写操作组合成一个逻辑单元的一种方式。事务中的所有读写操作被视作单个操作来执行：整个事务要么成功（提交（commit））要么失败（中止（abort），回滚（rollback））。

# 事务的棘手概念
几乎所有的关系型数据库和一些非关系数据库都支持事务

## ACID的含义
ACID代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）和持久性（Durability）。

### 原子性（Atomicity）
* 相似但又微妙不同的东西
* 不是关于并发（concurrent）的
* 原子性的定义特征是：能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。 或许 可中止性（abortability） 是更好的术语，但本书将继续使用原子性，因为这是惯用词。

### 一致性（Consistency）
对数据的一组特定陈述必须始终成立。即不变量（invariants）

### 隔离性（Isolation）
同时执行的事务是相互隔离的：它们不能相互冒犯

### 持久性（Durability）
* 持久性 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。
* 为了提供持久性保证，数据库必须等到这些写入或复制完成后，才能报告事务成功提交。

## 单对象和多对象操作

### 单对象写入
* 对单节点上的单个对象（例如键值对）上提供原子性和隔离性。
* 同样流行的是 比较和设置（CAS, compare-and-set） 操作，当值没有并发被其他人修改过时，才允许执行写操作。可以防止在多个客户端尝试同时写入同一个对象时丢失更新，但它们不是通常意义上的事务。CAS以及其他单一对象操作被称为“轻量级事务”，甚至出于营销目的被称为“ACID”
* 事务通常被理解为，将多个对象上的多个操作合并为一个执行单元的机制

### 多对象事务的需求
关系型数据库，文档型数据库，具有二级index的数据库

### 处理错误和中止
* ACID数据库基于这样的哲学：如果数据库有违反其原子性，隔离性或持久性的危险，则宁愿完全放弃事务
* 无主复制的数据存储，数据库将做尽可能多的事，运行遇到错误时，它不会撤消它已经完成的事情“ ——所以，从错误中恢复是应用程序的责任。
* 尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美


# 弱隔离级别
* 当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。
* 数据库一直试图通过提供事务隔离（transaction isolation） 来隐藏应用程序开发者的并发问题。从理论上讲，隔离可以通过假装没有并发发生，让你的生活更加轻松：可序列化（serializable） 的隔离等级意味着数据库保证事务的效果与连续运行（即一次一个，没有任何并发）是一样的。
* 可序列化有性能损失。因此，系统通常使用较弱的隔离级别来防止一部分。

## 读已提交 Read Committed
最基本的事务隔离级别

### 没有脏读
* 从数据库读时，只能看到已提交的数据（没有脏读（dirty reads））。
* 如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新
* 如果事务中止，则所有写入操作都需要回滚

### 没有脏写 
* 写入数据库时，只会覆盖已经写入的数据（没有脏写（dirty writes））。
* 如果事务更新多个对象，脏写会导致不好的结果

### 实现读已提交
* 防止脏写：行锁（row-level lock）
* 防止脏读：对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。 当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。

## 快照隔离和可重复读 Snapshot Isolation and Repeatable Read
很多地方可能会产生并发错误。是有些情况下，不能容忍这种暂时的不一致：
* 备份：备份进程运行时，数据库仍然会接受写入操作。因此备份可能会包含一些旧的部分和一些新的部分。如果从这样的备份中恢复，那么不一致（如消失的钱）就会变成永久的。
* 分析查询和完整性检查
* 快照隔离（snapshot isolation）：每个事务都从数据库的一致快照（consistent snapshot） 中读取——也就是说，每个事务也只能看到该特定时间点的旧数据

### 实现快照隔离
* 快照隔离的实现通常使用写锁来防止脏写(进行写入的事务会阻止另一个事务修改同一个对象，单读取不需要任何锁定)
* 读不阻塞写，写不阻塞读：数据库在处理一致性快照上的长时间查询时，可以正常地同时处理写入操作。且两者间没有任何锁定争用
* 数据库使用了脏读的机制的一般化。数据库必须保留一个对象的几个不同版本，事务需要看到数据库在不同的时间的状态。它并排维护着多个版本的对象----多版本并发控制（MVCC, multi-version concurrentcy control）
* 支持快照隔离的存储引擎通常也使用MVCC来实现读已提交隔离级别。一种典型的方法是读已提交为每个查询使用单独的快照，而快照隔离对整个事务使用相同的快照。

### 观察一致性快照的可见性规则
* 如果以下两个条件都成立，则可见一个对象：
    * 读事务开始时，创建该对象的事务已经提交。
    * 对象未被标记为删除，或如果被标记为删除，请求删除的事务在读事务开始时尚未提交。
* 长时间运行的事务可能会长时间使用快照，并继续读取（从其他事务的角度来看）早已被覆盖或删除的值。
* 由于从来不更新值，而是每次值改变时创建一个新的版本，数据库可以在提供一致快照的同时只产生很小的额外开销。

### 索引和快照隔离
* 使索引简单地指向对象的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本
* 使用仅追加的B树，每个写入事务（或一批事务）都会创建一颗新的B树

### 可重复读与命名混淆
* 快照隔离是一个有用的隔离级别，特别对于只读事务而言
* 在Oracle中称为可序列化（Serializable）的，在PostgreSQL和MySQL中称为可重复读（repeatable read）

## 防止丢失更新

### 原子写
* 原子操作通常通过在读取对象时，获取其上的排它锁来实现。以便更新完成之前没有其他事务可以读取它。这种技术有时被称为游标稳定性（cursor stability）
* 另一个选择是简单地强制所有的原子操作在单一线程上执行。
* but, ORM框架很容易意外地执行不安全的读取-修改-写入序列

### 显式锁定
数据库应该对该查询返回的所有行加锁

### 自动检测丢失的更新
* 原子操作和锁是通过强制读取-修改-写入序列按顺序发生，来防止丢失更新的方法。
* 允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列
* 不需要应用代码使用任何特殊的数据库功能

### 比较并设置（Compare And Set）
只有当前值从上次读取时一直未改变，才允许更新发生。如果当前值与先前读取的值不匹配，则更新不起作用，且必须重试读取-修改-写入序列。

### 冲突解决和复制
* 锁和CAS操作假定有一个最新的数据副本。但是多主或无主复制的数据库允许多个写入并发执行，并异步复制到副本上，无法保证有一份数据的最新副本。种复制数据库中的一种常见方法是允许并发写入创建多个冲突版本的值（也称为兄弟），并使用应用代码或特殊数据结构在事实发生之后解决和合并这些版本。
* 原子操作可以在复制的上下文中很好地工作，尤其当它们具有可交换性时。它可以防止复制副本丢失更新
* 最后写入为准（LWW）的冲突解决方法很容易丢失更新

## 写入偏差与幻读 Write Skew and Phantoms
并发写入间可能发生的竞争条件:
* 两个轮班医生同时休假
* 会议室预订系统
    * 首先检查是否存在相互冲突的预订（即预订时间范围重叠的同一房间）
    * 为了确保不会遇到调度冲突，你又需要可序列化的隔离级别了。
* 多人游戏
    * 使用唯一约束，否则您很容易发生写入偏差
* 抢注用户名
* 防止双重开支

### 写偏差的特征
* 这两个事务正在更新两个不同的对象（Alice和Bob各自的待命记录）
* 如果无法使用可序列化的隔离级别，则此情况下的次优选项可能是显式锁定事务所依赖的行

### 导致写入偏差的幻读 
一个事务中的写入改变另一个事务的搜索查询的结果，被称为幻读

### 物化冲突 materializing conflicts
将幻读变为数据库中一组具体行上的锁冲突


# 可序列化（Serializability）
被认为是最强的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就好像它们没有任何并发性，连续挨个执行一样。因此数据库保证，如果事务在单独运行时正常运行，则它们在并发运行时继续保持正确 —— 换句话说，数据库可以防止所有可能的竞争条件。

## 真的串行执行 Actual Serial Execution
设计用于**单线程执行的系统**有时可以比支持并发的系统更好，因为它可以避免锁的协调开销。但是其吞吐量仅限于单个CPU核的吞吐量。为了充分利用单一线程，需要与传统形式不同的结构的事务。

### 在存储过程中封装事务 Encapsulating transactions in stored procedures
应用程序必须提前将整个事务代码作为存储过程提交给数据库

### 存储过程的优点和缺点

#### cons
* 语言并没有跟上通用编程语言的发展
* 管理困难，调试困难，版本控制和部署起来也更为尴尬，更难测试，更难和用于监控的指标收集系统相集成
* performance-sensitive 比服务器对性能敏感多，因为单个数据库通常有许多应用服务器共享

#### pros
* 现代的存储过程实现放弃了PL/SQL，而是使用现有的通用编程语言：VoltDB使用Java或Groovy，Datomic使用Java或Clojure，而Redis使用Lua
* 存储过程与内存存储，使得在单个线程上执行所有事务变得可行。
* VoltDB还使用存储过程进行复制

### 分区
对于写入吞吐量较高的应用，单线程事务处理器可能成为一个严重的瓶颈。为了扩展到多个CPU核心和多个节点，可以对数据进行分区

### 串行执行小结 Summary of serial execution
* 每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。
* 仅限于活跃数据集可以放入内存的情况。很少访问的数据可能会被移动到磁盘，但如果需要在单线程执行的事务中访问，系统就会变得非常慢
* 写入吞吐量必须低到能在单个CPU核上处理，如若不然，事务需要能划分至单个分区，且不需要跨分区协调。
* 跨分区事务是可能的，但是它们的使用程度有很大的限制

## 两阶段锁定（2PL）
* 只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要独占访问（exclusive access）权限
* 写入不仅会阻塞其他写入，也会阻塞读，反之亦然
* 2PL提供了可序列化的性质，它可以防止早先讨论的所有竞争条件，包括丢失更新和写入偏差

### 实现两阶段锁
* 读与写的阻塞是通过为数据库中每个对象添加锁来实现的。锁可以处于共享模式（shared mode）或独占模式（exclusive mode）
* 事务A等待事务B释放它的锁，反之亦然。这种情况叫做死锁（Deadlock）。数据库会自动检测事务之间的死锁，并中止其中一个，以便另一个继续执行。被中止的事务需要由应用程序重试

### 两阶段锁定的性能
* 两阶段锁定下的事务吞吐量与查询响应时间要比弱隔离级别下要差得多（由于获取和释放所有这些锁的开销，但更重要的是由于并发性的降低）
* 基于锁实现的读已提交隔离级别可能发生死锁。当事务由于死锁而被中止并被重试时，它需要从头重做它的工作

### 谓词锁 Predicate locks
* 具有可序列化隔离级别的数据库必须防止幻读：一个事务改变另一个事务的搜索查询的结果
* 它类似于前面描述的共享/排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些搜索条件的对象
* 谓词锁甚至适用于数据库中尚不存在，但将来可能会添加的对象（幻象）
* 如果两阶段锁定包含谓词锁，则数据库将阻止所有形式的写入偏差和其他竞争条件，因此其隔离实现了可串行化。

### 索引范围锁 Index-range locks
* 不幸的是谓词锁性能不佳：如果活跃事务持有很多锁，检查匹配的锁会非常耗时
* 这种方法能够有效防止幻读和写入偏差。索引范围锁并不像谓词锁那样精确（它们可能会锁定更大范围的对象，而不是维持可串行化所必需的范围），但是由于它们的开销较低，所以是一个很好的折衷。

## 序列化快照隔离 Serializable Snapshot Isolation (SSI)
* 本章描绘了数据库中并发控制的黯淡画面。一方面，我们实现了性能不好（2PL）或者扩展性不好（串行执行）的可序列化隔离级别。另一方面，我们有性能良好的弱隔离级别，但容易出现各种竞争条件（丢失更新，写入偏差，幻读等）。序列化的隔离级别和高性能是从根本上相互矛盾的吗？
* 既用于单节点数据库（PostgreSQL9.1 以后的可序列化隔离级别）和分布式数据库（FoundationDB使用类似的算法）

### 悲观与乐观的并发控制
* **两阶段锁**是一种所谓的**悲观并发控制机制（pessimistic）** ：它是基于这样的原则：如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。这就像互斥，用于保护多线程编程中的数据结构。

* **序列化快照隔离**是一种**乐观（optimistic） 的并发控制技术**。在这种情况下，乐观意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。只有可序列化的事务才被允许提交。
    * 如果有足够的备用容量，并且事务之间的争用不是太高，乐观的并发控制技术往往比悲观的要好
    * 事务中的所有读取都是来自数据库的一致性快照。与早期的乐观并发控制技术相比这是主要的区别。在快照隔离的基础上，SSI添加了一种算法来检测写入之间的序列化冲突，并确定要中止哪些事务。

### 基于过时前提的决策
* 在快照隔离的情况下，原始查询的结果在事务提交时可能不再是最新的，因为数据可能在同一时间被修改
* 数据库如何知道查询结果是否可能已经改变？有两种情况需要考虑:

#### Detecting stale（陈腐的） MVCC reads
通过避免不必要的中止，SSI 保留快照隔离对从一致快照中长时间运行的读取的支持。

#### Detecting writes that affect prior reads
* 第二种情况要考虑的是另一个事务在读取数据之后修改数据
* 当事务写入数据库时，它必须在索引中查找最近曾读取受影响数据的其他事务

### Performance of serializable snapshot isolation
* 与两阶段锁定相比，可序列化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。
* 只读查询可以运行在一致的快照上，而不需要任何锁定，这对于读取繁重的工作负载非常有吸引力。
* 与串行执行相比，可序列化快照隔离并不局限于单个CPU核的吞吐量
* 中止率显著影响SSI的整体表现。例如，长时间读取和写入数据的事务很可能会发生冲突并中止，因此SSI要求同时读写的事务尽量短（只读长事务可能没问题）。对于慢事务，SSI可能比两阶段锁定或串行执行更不敏感。

# 本章小结
各式各样的错误被简化为一种简单情况：事务中止（transaction abort），而应用需要的仅仅是重试。
## 并发控制
### 读已提交
### 快照隔离
### 可序列化



## 脏读
​ 一个客户端读取到另一个客户端尚未提交的写入。读已提交或更强的隔离级别可以防止脏读。

## 脏写
​ 一个客户端覆盖写入了另一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。

## 读取偏差（不可重复读）
​ 在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。快照隔离经常用于解决这个问题，它允许事务从一个特定时间点的一致性快照中读取数据。快照隔离通常使用多版本并发控制（MVCC） 来实现。

## 更新丢失
两个客户端同时执行读取-修改-写入序列。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。快照隔离的一些实现可以自动防止这种异常，而另一些实现则需要手动锁定（SELECT FOR UPDATE）。

## 写偏差
​一个事务读取一些东西，根据它所看到的值作出决定，并将决定写入数据库。但是，写作的时候，决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常。

## 幻读
事务读取符合某些搜索条件的对象。另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入歪斜环境中的幻影需要特殊处理，例如索引范围锁定。

弱隔离级别可以防止这些异常情况，但是让应用程序开发人员手动处理其他应用程序（例如，使用显式锁定）。只有可序列化的隔离才能防范所有这些问题。我们讨论了实现可序列化事务的三种不同方法：

## 字面意义上的串行执行

​ 如果每个事务的执行速度非常快，并且事务吞吐量足够低，足以在单个CPU核上处理，这是一个简单而有效的选择。

## 两阶段锁定

​ 数十年来，两阶段锁定一直是实现可序列化的标准方式，但是许多应用出于性能问题的考虑避免使用它。

## 可串行化快照隔离（SSI）

​ 一个相当新的算法，避免了先前方法的大部分缺点。它使用乐观的方法，允许事务执行而无需阻塞。当一个事务想要提交时，它会进行检查，如果执行不可序列化，事务就会被中止。

​ 本章中的示例主要是在关系数据模型的上下文中。使用关系数据模型。但是，正如在讨论中，无论使用哪种数据模型，如“多对象事务的需求”中所讨论的，事务都是重要的数据库功能。

