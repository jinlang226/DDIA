分区主要是为了**可扩展性**

# 分区与复制
组合使用复制和分区：每个节点充当某些分区的领导者，其他分区充当追随者。

# 键值数据的分区
* ​如果分区是不公平的，一些分区比其他分区有更多的数据或查询，我们称之为**偏斜（skew）**
* 不均衡导致的高负载的分区被称为**热点（hot spot）**

## 根据键的范围分区
* 如果知道范围之间的边界，则可以轻松确定哪个分区包含某个值
* 为了均匀分配数据，分区边界需要依据数据调整
* 在每个分区中，我们可以按照一定的顺序保存键（参见“SSTables和LSM-树”）
* 缺点：某些特定的访问模式会导致热点

## 根据键的散列分区
一个好的散列函数可以将将偏斜的数据均匀分布

## 负载倾斜与消除热点
* 哈希分区可以帮助减少热点。但是，它不能完全避免它们
* 可以将主键分散为100种不同的主键,从而存储在不同的分区中
* 任何读取都必须要做额外的工作，还需要一些方法来跟踪哪些键需要被分割。

# 分片与次级索引
​ 次级索引的问题是它们不能整齐地映射到分区。有两种用二级索引对数据库进行分区的方法：基于文档的分区（document-based）和基于关键词（term-based）的分区。

## 按文档的二级索引
* 无论何时您需要写入数据库（添加，删除或更新文档），只需处理包含您正在编写的文档ID的分区即可。出于这个原因，文档分区索引也被称为本地索引（local index）
* 除非您对文档ID做了特别的处理，否则没有理由将所有具有特定颜色或特定品牌的汽车放在同一个分区中
* 这种查询分区数据库的方法有时被称为分散/聚集（scatter/gather），并且可能会使二级索引上的读取查询相当昂贵。

## 根据关键词(Term)的二级索引
* 我们可以构建一个覆盖所有分区数据的全局索引
* 全局索引也必须进行分区，但可以采用与主键不同的分区方式
* 关键词分区的全局索引优于文档分区索引的地方点是它可以使读取更有效率：不需要分散/收集所有分区，客户端只需要向包含关键词的分区发出请求。全局索引的缺点在于写入速度较慢且较为复杂，因为写入单个文档现在可能会影响索引的多个分区（文档中的每个关键词可能位于不同的分区或者不同的节点上） 。
* 对全局二级索引的更新通常是异步的

# 分区再平衡
所有这些更改都需要数据和请求从一个节点移动到另一个节点。 将负载从集群中的一个节点向另一个节点移动的过程称为再平衡（reblancing）。

## 平衡策略

### 反面教材：hash mod N
如果节点数量N发生变化，大多数密钥将需要从一个节点移动到另一个节点

### 固定数量的分区
* 创建比节点更多的分区，并为每个节点分配多个分区。例如，运行在10个节点的集群上的数据库可能会从一开始就被拆分为1,000个分区，因此大约有100个分区被分配给每个节点。
* 只有分区在节点之间的移动。分区的数量不会改变，键所指定的分区也不会改变。唯一改变的是分区所在的节点。
* 当分区大小“恰到好处”的时候才能获得很好的性能，如果分区数量固定，但数据量变动很大，则难以达到最佳性能。

### 动态分区
按键的范围进行分区的数据库（如HBase和RethinkDB）会动态创建分区。当分区增长到超过配置的大小时（在HBase上，默认值是10GB），会被分成两个分区，每个分区约占一半的数据【26】。与之相反，如果大量数据被删除并且分区缩小到某个阈值以下，则可以将其与相邻分区合并。此过程与B树顶层发生的过程类似

### 按节点比例分区
当一个新节点加入集群时，它随机选择固定数量的现有分区进行拆分，然后占有这些拆分分区中每个分区的一半，同时将每个分区的另一半留在原地。

## 运维：手动还是自动平衡
再平衡的过程中有人参与是一件好事。这比完全自动的过程慢，但可以帮助防止运维意外。

# 请求路由
 * 服务发现(service discovery)目标：高可用性
 * 许多分布式数据系统都依赖于一个独立的协调服务，比如ZooKeeper来跟踪集群元数据

 ## 执行并行查询
数据仓库查询的快速并行执行是一个专门的话题，由于分析有很重要的商业意义，可以带来很多利益。





