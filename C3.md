# 驱动数据库的数据结构
## log (append only)
## index (additional), 程序员手动选择
# 哈希索引
* 键值数据（key-value Data）
* 将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入一个新的段文件。然后，我们就可以对这些段进行压缩（compaction）
* 可以在执行压缩的同时将多个段合并在一起
* 注意问题：
    * 文件格式：二进制格式更快
    * 删除记录： Bitcask通过存储加速恢复磁盘上每个段的哈希映射的快照，可以更快地加载到内存中。
    * 崩溃回复
    * 部分写入记录
    * 并发控制
* 局限性：
    * 散列表必须放进内存
    * 范围查询效率不高：无法轻松扫描kitty00000和kitty99999之间的所有键

# SSTables和LSM树
* 排序字符串表（Sorted String Table），简称SSTable
* 要求每个键只在每个合并的段文件中出现一次（压缩过程已经保证）
* 优势：
    * 合并段是简单而高效的，即使文件大于可用内存
    * 跳到 key 的偏移位置并从那里扫描

## 构建和维护SSTables

## 用SSTables制作LSM树

## 性能优化

# B树
* 在B树的一个页面中对子页面的引用的数量称为分支因子
* 如果要更新B树中现有键的值，则搜索包含该键的叶页，更改该页中的值，并将该页写回到磁盘（对该页的任何引用保持有效）
* 具有 n 个键的B树总是具有 O(logN) 的深度

### 让B树更可靠
* B树实现通常会带有一个额外的磁盘数据结构：预写式日志（WAL, write-ahead-log）（也称为重做日志（redo log））
* 锁存器（latches）（轻量级锁）保护树的数据结构

## B树优化


# 比较B树和LSM树
## LSM树的优点
## LSM树的缺点

# 其他索引结构

# 数据仓库

# 列存储
## 列压缩
## 列存储中的排序顺序


$2$