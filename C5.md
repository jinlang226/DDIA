# part II
## 希望将数据库分布到多台机器上：

### 可扩展性

如果你的数据量、读取负载、写入负载超出单台机器的处理能力，可以将负载分散到多台计算机上。

### 容错/高可用性

如果你的应用需要在单台机器（或多台机器，网络或整个数据中心）出现故障的情况下仍然能继续工作，则可使用多台机器，以提供冗余。一台故障时，另一台可以接管。

### 延迟

如果在世界各地都有用户，你也许会考虑在全球范围部署多个服务器，从而每个用户可以从地理上最近的数据中心获取服务，避免了等待网络数据包穿越半个世界。


# C5
# 领导者与追随者
存储数据库副本的每个节点称为 副本（replica）
## 基于领导者的复制（leader-based replication） 
也称主动/被动（active/passive） 或 主/从（master/slave）复制
1. 副本之一被指定为 领导者（leader），也称为 主库（master|primary） 。当客户端要向数据库写入时，它必须将请求发送给领导者，领导者会将新数据写入其本地存储。
2. 其他副本被称为追随者（followers），亦称为只读副本（read replicas），从库（slaves），备库（ sencondaries），热备（hot-standby）。每当领导者将新数据写入本地存储时，它也会将数据变更发送给所有的追随者，称之为复制日志（replication log）记录或变更流（change stream）。每个跟随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。
3. 当客户想要从数据库中读取数据时，它可以向领导者或追随者查询。 但只有领导者才能接受写操作（从客户端的角度来看从库都是只读的）。

## 同步复制与异步复制
* ​ 同步复制的优点是，从库保证有与主库一致的最新数据副本。如果主库突然失效，我们可以确信这些数据仍然能在从库上上找到。缺点是，如果同步从库没有响应（比如它已经崩溃，或者出现网络故障，或其它任何原因），主库就无法处理写入操作。主库必须阻止所有写入，并等待同步副本再次可用。
* ​ 通常情况下，基于领导者的复制都配置为完全异步。 在这种情况下，如果主库失效且不可恢复，则任何尚未复制给从库的写入都会丢失。 这意味着即使已经向客户端确认成功，写入也不能保证 持久（Durable） 。 然而，一个完全异步的配置也有优点：即使所有的从库都落后了，主库也可以继续处理写入。

## 设置新从库
增加副本的数量，或替换失败的节点

## 处理节点宕机
* 从库失效：追赶恢复
* 主库失效：故障切换(failover)
    * 存在很多问题：异步复制、如果数据库需要喝其他外部存储相互协调、可能两个节点都以为自己是主库的情况

## 复制日志的实现

### 基于语句（statement）的复制
* 问题：
    * 非确定函数，rand/ now
    * 自增列，update/ where
    * 有副作用的语句
* 句被记录时，主库可以用固定的返回值替换任何不确定的函数调用，以便从库获得相同的值。但是由于边缘情况实在太多了，现在通常会选择其他的复制方法（切换到基于行的复制）。

### 传输预写式日志（WAL）
Write Ahead Log

### 逻辑日志复制（基于行）
* 复制和存储引擎使用不同的日志格式
* 更容易地保持向后兼容

###  基于触发器的复制
触发器允许您注册在数据库系统中发生数据更改（写入事务）时自动执行的自定义应用程序代码。触发器有机会将更改记录到一个单独的表中，使用外部程序读取这个表，再加上任何业务逻辑处理，会后将数据变更复制到另一个系统去。

# 复制延迟问题
异步从库读取数据时，如果从库落后，看到过时信息。不一致只是一个暂时的状态——如果停止写入数据库并等待一段时间，从库最终会赶上并与主库保持一致。出于这个原因，这种效应被称为 最终一致性（eventually consistency）

## 1 Reading Your Own Writes
* 提交新数据时，必须将其发送给领导者，但是当用户查看数据时，可以从追随者读取。如果数据经常被查看，但只是偶尔写入，这是非常合适的。
* But，异步复制， 对于用户而言，看起来像是刚起教的数据丢了
* 需要：读写一致性（read-after-write consistency），也称为 读己之写一致性（read-your-writes consistency）
    * 读用户可能已经修改过的内容时，都从主库读
    * 跟踪上次更新的时间，在上次更新后的一分钟内，从主库读
    * 记住最近一次写入的时间戳
    * if 副本分布在多个数据中心（出于可用性目的与用户尽量在地理上接近），则会增加复杂性。任何需要由领导者提供服务的请求都必须路由到包含主库的数据中心

## 2 单调读
* 从异步从库读取第二个异常例子是，用户可能会遇到 时光倒流（moving backward in time）
* 用户首先从新副本读取，然后从旧副本读取。时光倒流。为了防止这种异常，我们需要单调的读取。
* 即 如果先前读取到较新的数据，后续读取不会得到更旧的数据。
* 实现方式： 确保每个用户总是从同一个副本进行读取

## 3 一致前缀读
* 如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现
* 确保任何因果相关的写入都写入相同的分区

## 复制延迟的解决方案
* transactions(事务) exist: they are a way for a database to provide stronger guarantees so that the application can be simpler.
*  单节点事务已经存在了很长时间。然而在走向分布式（复制和分区）数据库时，许多系统放弃了事务

# 多主复制
​ 基于领导者的复制模型的自然延伸是允许多个节点接受写入。 复制仍然以同样的方式发生：处理写入的每个节点都必须将该数据更改转发给所有其他节点。 

## 多主复制的应用场景
### 运维多个数据中心
多领导者配置中可以在每个数据中心都有主库。
|     | 单主  |  多主   
|  ----  | ----  |   ----  
| 性能  | 写入必须穿过互联网，进入主库所在的数据中心。增加写入时间 | 每个写操作都能在本地进行处理，并与其他数据中心异步复制
| 容忍数据中心停机  | 故障切换可以使另一个数据中心里的追随者成为领导者 | 每个数据中心可以独立于其他数据中心继续运行，并且当发生故障的数据中心归队时，复制会自动赶上
| 容忍网络问题  | 对连接问题非常敏感，因为通过这个连接进行的写操作是同步的 | 临时的网络中断并不会妨碍正在处理的写入

### 需要离线操作的客户端
* 应用程序在断网之后仍然需要继续工作
* 每个设备都有一个充当领导者的本地数据库（它接受写请求）

### 协同编辑
例如，Etherpad 和 Google Docs 


## 处理写入冲突

### 同步与异步冲突检测
* 如果您想要同步冲突检测，那么您可以使用单主程序复制。

### 避免冲突
* 可以确保来自特定用户的请求始终路由到同一数据中心
* 可能需要更改指定的记录的主库——可能是因为一个数据中心出现故障

### 收敛至一致的状态
所有副本必须在所有变更复制完成时收敛至一个相同的最终值。