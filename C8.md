# 故障与部分失效
在分布式系统中，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式被破坏。这被称为部分失效（partial failure）。难点在于部分失效是不确定性的（nonderterministic）

## 云计算与超级计算机 Cloud Computing and Supercomputing
### high-performance computing (HPC)
computationally inten‐ sive scientific computing tasks

### cloud computing
与多租户数据中心，连接IP网络的商品计算机（通常是以太网），弹性/按需资源分配以及计量计费等相关联

### Many differences
 * we must accept the possibility of partial failure and build fault-tolerance mechanisms into the software
 * In distributed systems, suspicion, pessimism, and paranoia pay off.

# Unreliable Networks
* The network is the only way those machines can communicate
* The internet and most internal networks in datacenters (often Ethernet) are asyn‐ chronous packet networks.
* 在这种网络中，一个节点可以向另一个节点发送一个消息（一个数据包），但是网络不能保证它什么时候到达，或者是否到达。如果您发送请求并期待响应，则很多事情可能会出错

## Network Faults in Practice
处理网络故障并不意味着容忍它们：如果你的网络通常是相当可靠的，一个有效的方法可能是当你的网络遇到问题时，简单地向用户显示一条错误信息。但是，您确实需要知道您的软件如何应对网络问题，并确保系统能够从中恢复。

## Detecting Faults

## Timeouts and Unbounded Delays
* 如果超时是检测故障的唯一可靠方法，那么超时应该等待多久？不幸的是没有简单的答案。
* 将其负载转移到其他节点可能会导致级联失效（cascading failure）（在极端情况下，所有节点都宣告对方死亡，并且所有节点都停止工作）
* 每个数据包传递永远不会比$d$更长，一个非故障节点总是在一段时间内处理一个请求r，2d + r 是总时间

### Network congestion and queueing
* variability of packet delays on computer networks is most often due to queueing
* TCP执行流量控制（flow control）（也称为拥塞避免（congestion avoidance）或背压（backpressure））
* 由于UDP（User Datagram Protocol）不执行流量控制并且不重传丢失的分组，所以避免了可变网络延迟的一些原因（尽管它仍然易受切换队列和调度延迟的影响）。
* 您只能通过实验方式选择超时：测量延长的网络往返时间和多台机器的分布，以确定延迟的预期可变性。然后，考虑到应用程序的特性，可以确定故障检测延迟与过早超时风险之间的适当折衷。
* 连续测量响应时间及其变化（抖动），并根据观察到的响应时间分布自动调整超时时间

## Synchronous Versus Asynchronous Networks 同步网络 vs 异步网络
### 同步
​​当您通过电话网络拨打电话时，它会建立一个电路。这种网络是同步的：即使数据经过多个路由器，也不会受到排队的影响，因为呼叫的16位空间已经在网络的下一跳中保留了下来。而且由于没有排队，网络的最大端到端延迟是固定的。我们称之为有限延迟（bounded delay）。

### Can we not simply make network delays predictable?
* 电话网络中的电路与TCP连接有很大不同：电路是固定数量的预留带宽，在电路建立时没有其他人可以使用，而TCP连接的数据包机会性地使用任何可用的网络带宽。
* 数据中心网络和互联网：以太网和IP是**分组交换协议**
* 它们针对突发流量（bursty traffic）进行了优化

# 不可靠的时钟
每台机器都有自己的时间概念，可能比其他机器稍快或更慢。可以在一定程度上同步时钟：最常用的机制是网络时间协议（NTP），它允许根据一组服务器报告的时间来调整计算机时钟【37】。服务器则从更精确的时间源（如GPS接收机）获取时间。

## 单调钟与时钟 Monotonic Versus Time-of-Day Clocks
### 时钟 Time-of-day clocks
* 时钟是您直观地了解时钟的依据：它根据某个日历（也称为挂钟时间（wall-clock time））返回当前日期和时间
* 时钟通常与NTP同步，这意味着来自一台机器的时间戳（理想情况下）意味着与另一台机器上的时间戳相同。但是如下节所述，时钟也具有各种各样的奇特之处。特别是，如果本地时钟在NTP服务器之前太远，则它可能会被强制重置，看上去好像跳回了先前的时间点。这些跳跃以及他们经常忽略闰秒（Leap seconds）的事实，使时钟不能用于测量经过时间

### 单调钟 Monotonic clocks
单调钟适用于测量持续时间（时间间隔）

## 时钟同步与准确性 Clock Synchronization and Accuracy
单调钟不需要同步，但是时钟需要根据NTP服务器或其他外部时间源来设置才能有用
* 计算机中的石英钟不够精确：它会漂移（drifts）

## 依赖同步时钟 Relying on Synchronized Clocks

### 有序事件的时间戳
* LWW无法区分高频顺序写入
* 两个节点可以独立生成具有相同时间戳的写入，特别是在时钟仅具有毫秒分辨率的情况下。为了解决这样的冲突，还需要一个额外的决胜值（tiebreaker）（可以简单地是一个大随机数），但这种方法也可能会导致违背因果关系
* So-called logical clocks [56, 57], which are based on incrementing counters rather than an oscillating quartz crystal, are a safer alternative for ordering events (see “Detecting Concurrent Writes” on page 184). Logical clocks do not measure the time of day or the number of seconds elapsed, only the relative ordering of events (whether one event happened before or after another). In contrast, time-of-day and monotonic clocks, which measure actual elapsed time, are also known as physical clocks. We’ll look at ordering a bit more in “Ordering Guarantees” on page 339.

### 时钟读数存在置信区间
不幸的是，大多数系统不公开这种不确定性：例如，当调用clock_gettime()时，返回值不会告诉你时间戳的预期错误，所以你不知道其置信区间是5毫秒还是5年。

### 全局快照的同步时钟 Synchronized clocks for global snapshots
每个置信区间包含最早和最近可能的时间戳（ $A = [A{earliest}, A{latest}]$， $B=[B{earliest}, B{latest}] $），这两个区间不重叠（即：$A{earliest} < A{latest} < B{earliest} < B{latest}$）

## 暂停进程 Process Pauses
一个节点如何知道它仍然是领导者（它并没有被别人宣告为死亡），并且它可以安全地接受写入？
* One option is for the leader to obtain a lease from the other nodes, which is similar to a lock with a timeout [63]. Only one node can hold the lease at any one time. In order to remain leader, the node must periodically renew the lease before it expires.